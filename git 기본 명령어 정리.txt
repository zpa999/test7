
//1차시
- git설치 후 환경변수 설정
C:\ProgramFiles\Git\cmd


- git 설치 후 주요 설정
git config --global core.editor code --wait
git config --global user.name "zpa999"
git config --global user.email "zpa999@nate.com"
git config init.defaultBranch main


- git 주요 설정 확인
git config --list


- git 작업디렉토리 생성 및 파일 작성 및 확인
git init
echo create > hello.txt
cat hello.txt


- 파일 생성 후
git status --long
git status --short
git add 
git commit -m 메시지
옵션 대소문자 -- 두개(풀네임) 개념 및 - 한개(축약) 개념


- 스테이징 삭제
git rm --cached hello.txt


- git log 여러 커밋 목록 확인
git log
git log --oneline
git log --all --oneline --graph


- git show 특정한 커밋 정보를 확인
git show


//2차시
- 클론
- 원격저장소와 동일한 이름에 폴더를 로컬에 생성
git clone [복사된주소]


- 하부 폴더에
git clone [복사된주소] [새로운 폴더]


- 현재 폴더에 바로 복제
git clone [복사된주소] . 


- 원격 저장소 별칭 이름 점검
git remote
git remote -v


- 원격 저장소 연결
연결 : git remote add 저장소별칭 https://~
자세한 정보 : git remote show origin
이름수정 : git remote rename origin org
삭제 : git remote rm org


//3차시

- git push <저장소별칭> <원격브랜치명>
최초 : git push origin <원격브랜치명> 
성공 이후 : git push
git push origin --all 


- 로컬과 원격 동일 브랜치 이름 사용이 일반적이므로 서로 동일한 브랜치로 push 설정
git config --global push.default current


- full
git pull [원격저장소별칭] [원격저장소에서 받아오고자하는 브랜치이름]


- git pull = git fetch + git merge
- git fetch origin


- 패치 후 로컬 커밋과 원격 커밋 차이 확인(원격에는 있지만 로컬에는 없는것을 확인)
git log main..origin/main


- 패치 후 내용확인
git diff main origin/main
 
- git log --all --oneline --graph
- git merge origin/main


- git branch --all
 

//4차시
파일 관리 및 복원

- 작업 디렉토리에서 file 삭제 리눅스 명령어
rm [file]


- 작업디렉토리와 스테이징 영역 명령 파일 삭제
git rm [file]


- 스테이징영역 삭제 : git rm --cached 파일명


- git ls-files(옵션 없음)
Git이 '추적'하고 있는 모든 파일 목록을 보여줍니다. 여기에는 이미 커밋된 파일과 스테이징된 파일이 모두 포함됩니다.


- 스테이징영역만 확인 : git ls-files --stage


- git commit 이후
- git show


복원
- 작업디렉토리의 파일 f를 스테이징 영역의 파일로 복구
git restore 파일명


- 깃저장소의 최신 커밋 상태의 파일 f를 스테이징 영역에 복구
git restore --staged 파일명 또는 .


-깃 저장소 내용을 작업폴더에 복구(현재 헤더가 가르키는 커밋내용으로)
git restore --source=HEAD [--worktree] f


- 3영역 모두 저장소 내용으로 수정
git restore --source=HEAD --staged --worktree f 


이전 커밋으로 복원
git restore --source=HEAD~1 --staged f


파일 삭제한 후 커밋해버린 경우
git restore --source=HEAD~1 -- [file Name]
git restore --source=HEAD~1 -- . (삭제한 모든 파일 복원)


//5차시
브랜치 개요와 관리

기본 브랜치 이름 변경 : git config --global init.defaultBranch main

이미 생성된 저장소 브랜치 이름 수정
git branch -M newBname

브랜치 확인
git branch

브랜치 단순 생성(이동 x)
git branch bname

생성하고 새 브랜치로 HEAD 이동
git switch -c bname
git checkout -b bname


- 헤더를 분리하는 목적
detached HEAD는 왜 사용하나요?
과거 특정 시점의 코드를 안전하게 탐색하고 테스트하기 위해.
다른 브랜치에 영향을 주지 않고 임시/실험적인 작업을 하기 위해.
핵심은 무엇인가요?
HEAD가 브랜치가 아닌 특정 커밋을 직접 가리키는 상태입니다.
주의할 점은 무엇인가요?
이 상태에서 만든 커밋은 사라질 수 있으므로, 보존하려면 반드시 새로운 브랜치를 생성해야 합니다.


헤더 분리 후 수정한 내용은 사라짐!!!
반드시 git checkout main 으로!!!


단순 브랜치 이동
git switch [bname]
git checkout [bname]

이전 브랜치로 이동
git switch -
git checkout -

>>
!!! 현재 브랜치에서 마지막 커밋 이전 커밋으로 이동(내용도 이전으로 변경됨)
이전 커밋으로 : git checkout HEAD~
특정 커밋으로 : git checkout 커밋아이디(조심해야 함!!!)
git checkout main 으로 항상 확인

하지만 로컬에서 파일이 수정된 상황에서는 커밋 이동 안됨!!!
>>


이동 커밋
HEAD~(틸드) 또는 HEAD^(커렛) 또는 HEAD^^, commit ID 사용
HEAD~ 또는 HEAD~1 : 바로 이전 커밋
HEAD~2 : 2단계 이전 커밋 의미
간단히 말해, 단순히 뒤로 몇 칸 이동하고 싶을 때는 ~를, Merge 커밋의 다른 부모 브랜치로 이동하고 싶을 때는 ^를 사용하면 편리합니다. 


병합
이미 병합된 브랜치 삭제 : git branch -d 브랜치이름
병합되지 않아도 삭제 : git branch -D 브랜치이름

브랜치 병합 여부 --merged 와 --no-merged 로 확인가능


//6차시
병합 및 충돌 해결

병합은 항상 현재 브랜치 기준으로 진행됨!
빨리감기 병합(기존 브랜치는 유지됨!)
3 way 병합

- 병합
git merge 브랜치명


빨리감기 병합 상태에서 non fast forward 병합, 무조건 3way 병
git merge dev1 --no-ff
3way 병합 수행


현재 브랜치와 병합
git merge bugfix -m 'merge mag'

병합시 충돌 발생할 경우 직접 파일 수정 후 저장 및
git commit -am 'msg'

병합취소
git merge --abort

다시병합
git merge feat/list





